namespace vwa::bc
{
    // Possible optimization: remove infrequently used instructions like CtoD and replace them with CtoI ItoD to reduce instruction count.
    // It might also help to remove smaller integer types from the instruction set, since their performance advantage is negligible compared to the overhead of the interpreter.
    enum BcInstruction : uint8_t
    {
        Exit, // Terminates the program. Args: i32 (exit code)

        // Control flow
        Jump,        // Jump to adress and continue execution. Args: u64 address(passed in bytecode)
        JumpIfFalse, // Jump to adress if the last value is false. Args: bool condition,u64 address(passed in bytecode)
        JumpIfTrue,  // Jump to the address if the argument is true. Args:  bool condition,u64 address(passed in bytecode)
        StackJump,   // Jump to the address on top of the stack. Needed for lambda functions. Args: u64 address
        JumpFunc,    // Jump to the address, while setting the base pointer and return address. Args: u64 address, u64 nBytes for args, all passed in bytecode
        JumpFFI,     // Jump to the ffi function at the given address. Args: u64 address. No stack pointer needs to be set.
        CallFunc,    // Placeholer generated by the compiler. The linker replaces this with JumpFunc or JumpFFI. It is not relevant to the compiler if this is a ffi or internal function.
        Return,      // Restore base pointer and jump to the return address on the stack. Args: u64 nBytes for rval

        // Stack manipulation
        Push, // Increment the stack pointer. This does not allow for intialization of the value. Args: u64 nBytes
        Pop,  // Decrement the stack pointer. Args: u64 nBytes
        // If performance is bad I might also add instructions for pushing data from the bytecode.

        // Data manipulation
        ReadAbs,  // Reads data at an absolute address. Args: u64 address, u64 nBytes
        WriteAbs, // Writes data at an absolute address. Args: u64 address, u64 nBytes
        ReadRel,  // Reads data relative to the base pointer. Used for local variables and access to the constant pool. Args: i64 offset, u64 nBytes If the signed offset causes problems I will add a bool indicating whether to add or subtract.
        WriteRel, // Writes data relative to the base pointer. Used for local variables and access to the constant pool. Args: i64 offset, u64 nBytes

        // Arithmetic For now every data type has its own instruction. If this slows down the vm I might just convert all integer types to long first.
        // There are no operations for characters, if for some reason you must perform arithmetic on characters, they are converted to integers first.
        // Pointers are assumed to be longs
        // TODO: unsigned types
        // TODO: consider negation instructions
        AddI,
        SubI,
        MulI,
        DivI,
        ModI,
        PowerI,

        AddL,
        SubL,
        MulL,
        DivL,
        ModL,
        PowerL,

        AddF,
        SubF,
        MulF,
        DivF,
        PowerF,

        AddD,
        SubD,
        MulD,
        DivD,
        PowerD,

        // Conversion
        LtoI,
        FtoI,
        DtoI,
        CtoI,

        ItoL,
        FtoL,
        DtoL,
        CtoL,

        ItoF,
        LtoF,
        DtoF,
        CtoF,

        ItoD,
        LtoD,
        FtoD,
        CtoD,

        ItoC,
        LtoC,
        FtoC,
        DtoC,

        // Boolean logic
        And, // Args: 2 chars(booleans)
        Or,  // Args: 2 chars(booleans)
        Not, // Args: 1 char(boolean)

        // Comparison
        GreaterThanF,
        LessThanF,
        GreaterThanOrEqualF,
        LessThanOrEqualF,
        EqualF,
        NotEqualF,

        GreaterThanD,
        LessThanD,
        GreaterThanOrEqualD,
        LessThanOrEqualD,
        EqualD,
        NotEqualD,

        // Integer types don't have the orEqual instructions since they can be rewritten using other instructions.
        GreaterThanI,
        LessThanI,
        EqualI,
        NotEqualI,

        GreaterThanL,
        LessThanL,
        EqualL,
        NotEqualL,

        GreaterThanC,
        LessThanC,
        EqualC,
        NotEqualC,
    };
    union BcToken
    {
        BcInstruction instruction;
        uint8_t value;
    };
};